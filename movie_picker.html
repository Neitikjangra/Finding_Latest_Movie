<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Trending Movie List</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use Inter font -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body { font-family: 'Inter', sans-serif; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">

    <!-- Main Application Container -->
    <div id="app-container" class="bg-white p-6 md:p-10 rounded-xl shadow-2xl w-full max-w-2xl">
        <h1 class="text-3xl font-extrabold text-indigo-700 mb-2">ðŸŽ¬ Trending Film Finder</h1>
        <p class="text-gray-600 mb-6">
            Get a list of movies and TV shows from Bollywood and Hollywood, either trending globally or personalized to your mood!
        </p>

        <!-- Input and Button Forms -->
        <div class="space-y-4">
            <!-- 1. Trending Search Button (Original Feature) -->
            <button
                id="pickButton"
                onclick="pickMovie()"
                class="w-full bg-indigo-600 text-white p-3 rounded-lg font-semibold hover:bg-indigo-700 transition duration-200 shadow-md active:shadow-none"
            >
                Find 10-15 **Trending** Films Now! (Worldwide)
            </button>
            
            <!-- Separator and New Mood Search Feature -->
            <div class="mt-4 pt-4 border-t border-gray-200 space-y-3">
                <p class="text-sm font-semibold text-gray-700">Or, search based on your mood/interest:</p>
                
                <!-- Input for Mood/Interest -->
                <input
                    type="text"
                    id="moodInput"
                    placeholder="E.g., I need a high-energy sci-fi movie to cheer me up."
                    class="w-full p-3 border border-gray-300 rounded-lg transition duration-150 focus:ring-teal-500 focus:border-teal-500"
                >
                
                <!-- Button for Mood Search -->
                <button
                    id="searchMoodButton"
                    onclick="searchByMood()"
                    class="w-full bg-teal-600 text-white p-3 rounded-lg font-semibold hover:bg-teal-700 transition duration-200 shadow-md active:shadow-none"
                >
                    Get Personalized Recommendations
                </button>
            </div>
        </div>

        <!-- Result Display Area -->
        <div id="resultArea" class="mt-8 hidden">
            <h2 id="resultTitle" class="text-2xl font-bold text-gray-800 mb-4 border-b pb-2"></h2>
            
            <!-- This container will now hold the list of movie cards -->
            <div id="movieCardContainer" class="space-y-4">
                <!-- Movie list items will be injected here -->
            </div>

            <!-- Sources/Citations (Will be hidden since grounding is removed) -->
            <div id="sourcesContainer" class="mt-8 hidden">
                <p class="text-sm font-semibold text-gray-500 mb-1">Sources (for grounding movie data):</p>
                <ul id="sourceList" class="list-disc list-inside space-y-1 text-sm text-gray-500">
                    <!-- Sources will be injected here -->
                </ul>
            </div>
        </div>

        <!-- Loading Indicator (Spinner) -->
        <div id="loadingIndicator" class="mt-8 text-center hidden">
            <svg class="animate-spin h-8 w-8 text-indigo-600 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p class="text-indigo-600 mt-2">Aggregating movie data...</p>
        </div>

        <!-- Error Message -->
        <div id="errorArea" class="mt-8 p-4 bg-red-100 border border-red-400 text-red-700 rounded-lg hidden" role="alert">
            <p class="font-bold">Error:</p>
            <p id="errorMessage"></p>
        </div>
    </div>

    <!-- Firebase and API Setup -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Set Firestore log level to Debug (Recommended)
        setLogLevel('Debug');

        // Global Firebase variables
        window.firebaseApp = null;
        window.db = null;
        window.auth = null;
        window.userId = null;

        // Global API Model
        const MODEL_NAME = "gemini-2.5-flash-preview-09-2025";

        // Mandatorily provided global variables
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        /**
         * Initializes Firebase and authenticates the user.
         */
        async function initApp() {
            try {
                if (!Object.keys(firebaseConfig).length) {
                    console.warn("Firebase config is missing. Skipping database initialization.");
                    return; 
                }

                window.firebaseApp = initializeApp(firebaseConfig);
                window.db = getFirestore(window.firebaseApp);
                window.auth = getAuth(window.firebaseApp);

                // Set up auth state listener
                onAuthStateChanged(window.auth, (user) => {
                    if (user) {
                        window.userId = user.uid;
                        console.log("Firebase Auth State Changed: User ID:", window.userId);
                    } else {
                        console.log("Firebase Auth State Changed: No user signed in.");
                    }
                });

                // Sign in using custom token or anonymously
                if (initialAuthToken) {
                    await signInWithCustomToken(window.auth, initialAuthToken);
                    console.log("Signed in with custom token.");
                } else {
                    await signInAnonymously(window.auth);
                    console.log("Signed in anonymously.");
                }

            } catch (error) {
                console.error("Firebase Initialization Error:", error);
                document.getElementById('errorMessage').textContent = `Initialization failed: ${error.message}`;
                document.getElementById('errorArea').classList.remove('hidden');
            }
        }

        // --- Utility Functions for Gemini API calls and HTML escaping ---

        /**
         * MANDATED FIX: Constructs the correct API URL for the environment.
         * Using the explicit API key provided by the user in chat history
         * to override the failing environment injection.
         */
        function getApiUrl() {
            // Re-instating the API key provided by the user.
            // This is a direct attempt to solve the persistent 401 UNAUTHORIZED errors.
            const apiKey = "AIzaSyB3nmVidvjikNT_Tlg9j7zYy9cySoKoM20";
            return `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${apiKey}`; 
        }

        /**
         * Makes a fetch call with exponential backoff.
         */
        window.fetchWithBackoff = async function(url, options, retries = 0) {
            const maxRetries = 5;
            try {
                // Log the URL to verify the correct structure is being used
                console.log(`[API_INFO] Attempting fetch to: ${url}`); 
                const response = await fetch(url, options);
                
                if (!response.ok) {
                    console.error(`API Request failed with HTTP status: ${response.status}`);
                    // Throw a specific error for 401
                    if (response.status === 401) {
                        console.error("CRITICAL 401 UNAUTHORIZED: The API key was rejected or not sent.");
                        throw new Error("Authentication Failed (Error 401). The API key is invalid or unauthorized. Please verify the key is correct and has the Gemini API enabled.");
                    }
                    // FIX: Add specific handling for 400 Bad Request
                    if (response.status === 400) {
                        console.error("CRITICAL 400 BAD REQUEST: The request payload is invalid.");
                        const errorBody = await response.json();
                        console.error("API Error Body:", errorBody);
                        throw new Error("Bad Request (Error 400). The app sent an invalid request to the API. This is often due to combining incompatible features (like Grounding and JSON mode).");
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                if (retries < maxRetries) {
                    const delay = Math.pow(2, retries) * 1000;
                    // Do not log retries as errors, just warnings
                    console.warn(`Request failed. Retrying in ${delay / 1000}s... (Attempt ${retries + 1}/${maxRetries})`, error);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return window.fetchWithBackoff(url, options, retries + 1);
                }
                throw new Error("API request failed after multiple retries.");
            }
        };
        
        /**
         * Helper function to escape strings for passing to onclick handlers.
         */
        function escapeHtml(unsafe) {
            if (!unsafe) return '';
            return unsafe
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
        }
        
        /**
         * Helper function to unescape strings passed from onclick handlers.
         */
        function unescapeHtml(safe) {
            if (!safe) return '';
            return safe
                .replace(/&amp;/g, "&")
                .replace(/&lt;/g, "<")
                .replace(/&gt;/g, ">")
                .replace(/&quot;/g, "\"")
                .replace(/&#039;/g, "'");
        }


        // --- UI and Rendering Helpers ---

        /**
         * Updates the UI state (loading, error, result area visibility).
         */
        function updateUIState(isLoading, isError = false, errorMessage = '') {
            const pickButton = document.getElementById('pickButton');
            const searchMoodButton = document.getElementById('searchMoodButton');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const errorArea = document.getElementById('errorArea');
            const resultArea = document.getElementById('resultArea');
            
            // Disable/Enable all action buttons
            pickButton.disabled = isLoading;
            searchMoodButton.disabled = isLoading; 

            loadingIndicator.classList.toggle('hidden', !isLoading);
            errorArea.classList.add('hidden');
            
            // Hide result area if loading or showing an error
            resultArea.classList.toggle('hidden', isLoading || isError);

            if (isError) {
                document.getElementById('errorMessage').innerHTML = errorMessage; // Use innerHTML to render bold tag
                errorArea.classList.remove('hidden');
            }
        }

        /**
         * Renders the movie list and sources based on the API response.
         */
        function renderResults(movies, sources, resultTitleText) {
            const movieCardContainer = document.getElementById('movieCardContainer');
            const resultTitle = document.getElementById('resultTitle');
            const sourceList = document.getElementById('sourceList');
            const sourcesContainer = document.getElementById('sourcesContainer');

            resultTitle.textContent = resultTitleText;
            movieCardContainer.innerHTML = '';
            
            if (movies.length > 0) {
                movies.forEach((movie, index) => {
                    const card = document.createElement('div');
                    // Use color coding based on origin
                    const originColor = movie.origin === 'Bollywood' ? 'bg-pink-50 border-pink-500 text-pink-800' : 'bg-blue-50 border-blue-500 text-blue-800';
                    
                    card.className = `p-4 rounded-xl border-l-8 shadow-md transition duration-150 ease-in-out hover:shadow-lg ${originColor}`;
                    
                    // Handle rating display: show one decimal place for number, or 'N/A'
                    const displayRating = typeof movie.rating === 'number' ? movie.rating.toFixed(1) : (movie.rating || 'N/A');

                    // Escape strings before placing them in the onclick attribute
                    const safeTitle = escapeHtml(movie.title);
                    const safeSummary = escapeHtml(movie.summary);
                    const safeGenre = escapeHtml(movie.genre);
                    const safeOrigin = escapeHtml(movie.origin);

                    card.innerHTML = `
                        <div class="flex justify-between items-start mb-2">
                            <h3 class="text-xl font-bold">
                                <span class="text-gray-500 mr-2">${index + 1}.</span> ${movie.title} (${movie.year})
                            </h3>
                            <span class="text-xs font-semibold p-1 px-3 rounded-full ${movie.origin === 'Bollywood' ? 'bg-pink-100 text-pink-600' : 'bg-blue-100 text-blue-600'}">
                                ${movie.origin}
                            </span>
                        </div>
                        
                        <div class="text-sm space-y-1 mb-3 text-gray-700 ml-4">
                            <p><strong>Genre:</strong> ${movie.genre}</p>
                            <p><strong>Rating:</strong> <span class="font-extrabold text-lg text-yellow-600">${displayRating}</span></p>
                        </div>
                        
                        <p class="text-gray-600 italic mt-2">${movie.summary}</p>
                        
                        <!-- Feature Buttons -->
                        <div class="mt-4 flex justify-end flex-wrap gap-2">
                            <!-- Pitch Generator Button -->
                            <button
                                onclick="window.generateMoviePitch(this, '${safeTitle}', '${safeSummary}', '${safeGenre}', '${safeOrigin}')"
                                class="pitch-button text-sm bg-purple-600 text-white p-2 px-4 rounded-full font-medium hover:bg-purple-700 transition duration-200 shadow-lg active:shadow-md flex items-center"
                            >
                                Generate Pitch âœ¨
                            </button>
                            <!-- NEW FEATURE: Theme Song Button -->
                            <button
                                onclick="window.generateThemeSongIdea(this, '${safeTitle}', '${safeSummary}', '${safeGenre}', '${safeOrigin}')"
                                class="song-button text-sm bg-green-600 text-white p-2 px-4 rounded-full font-medium hover:bg-green-700 transition duration-200 shadow-lg active:shadow-md flex items-center"
                            >
                                Theme Song Idea âœ¨
                            </button>
                        </div>
                        
                        <!-- Pitch Display Area -->
                        <div class="pitch-display mt-3 p-3 border border-purple-300 bg-purple-50 rounded-lg hidden">
                            <!-- Pitch will be displayed here -->
                        </div>
                        <!-- NEW FEATURE: Song Display Area -->
                        <div class="song-display mt-3 p-3 border border-green-300 bg-green-50 rounded-lg hidden">
                            <!-- Song ideas will be displayed here -->
                        </div>
                    `;
                    movieCardContainer.appendChild(card);
                });
            } else {
                movieCardContainer.innerHTML = "<p class='text-gray-500 p-4'>The API did not return any structured movie data. Try modifying the search query or check the console for errors.</p>";
            }

            // Update sources container
            // This will now always be hidden, which is fine.
            sourceList.innerHTML = '';
            if (sources && sources.length > 0) {
                sources.forEach(source => {
                    const li = document.createElement('li');
                    const a = document.createElement('a');
                    a.href = source.uri;
                    a.target = "_blank";
                    a.textContent = source.title;
                    a.className = "text-indigo-600 hover:text-indigo-800 transition duration-1S0 break-words";
                    li.appendChild(a);
                    sourceList.appendChild(li);
                });
                sourcesContainer.classList.remove('hidden');
            } else {
                sourcesContainer.classList.add('hidden');
            }
        }
        
        // --- API Execution Functions ---

        /**
         * Main function to pick a list of trending movies using the Gemini API.
         */
        window.pickMovie = async function() {
            updateUIState(true); // Start loading

            const apiUrl = getApiUrl();

            // Define the JSON schema for the list of movies
            const responseSchema = {
                type: "ARRAY",
                items: {
                    type: "OBJECT",
                    properties: {
                        "title": { "type": "STRING", "description": "Movie or TV Show Title" },
                        "year": { "type": "NUMBER", "description": "Release year" },
                        "genre": { "type": "STRING", "description": "Primary genre(s)" },
                        "origin": { "type": "STRING", "enum": ["Hollywood", "Bollywood"], "description": "Origin of the production" },
                        "rating": { "type": "NUMBER", "description": "Aggregate rating on a 1-10 scale (e.g., 8.5)" }, 
                        "summary": { "type": "STRING", "description": "A brief, one-sentence plot summary" }
                    },
                    "required": ["title", "year", "genre", "origin", "rating", "summary"]
                },
                "description": "A list of 10 to 15 currently trending movies and TV shows from Bollywood and Hollywood."
            };


            const systemPrompt = "You are a professional film data aggregator. Your sole task is to generate a JSON array of 10 to 15 recent and popular Bollywood and Hollywood movies or TV shows based on your internal knowledge. Ensure each entry adheres exactly to the provided JSON schema. Do not include any text outside of the JSON block.";
            const userQuery = "Find 10 to 15 recent and popular movies and TV shows from both Bollywood and Hollywood. Provide detailed information for each as structured JSON.";

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                // FIX: Removed "tools" key, as it's incompatible with "responseSchema".
                // tools: [{ "google_search": {} }], 
                systemInstruction: { parts: [{ text: systemPrompt }] },
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: responseSchema
                }
            };

            let movies = [];
            let sources = []; // Will remain empty, which is fine.
            
            try {
                const result = await window.fetchWithBackoff(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const candidate = result.candidates?.[0];

                if (candidate && candidate.content?.parts?.[0]?.text) {
                    const jsonText = candidate.content.parts[0].text;
                    try {
                        movies = JSON.parse(jsonText);
                    } catch (e) {
                        console.error("Failed to parse JSON response:", e);
                        throw new Error("The API returned data in an unexpected format. Please try again.");
                    }

                    // Extract grounding sources (no longer applicable, but code handles it)
                    const groundingMetadata = candidate.groundingMetadata;
                    if (groundingMetadata && groundingMetadata.groundingAttributions) {
                        sources = groundingMetadata.groundingAttributions
                            .map(attribution => ({
                                uri: attribution.web?.uri,
                                title: attribution.web?.title,
                            }))
                            .filter(source => source.uri && source.title);
                    }
                }
                
                renderResults(movies, sources, `Top ${movies.length} Popular Films (Bollywood & Hollywood)`);

            } catch (error) {
                console.error("Movie Picker API Error:", error);
                updateUIState(false, true, `Failed to get trending films: ${error.message}`);
            } finally {
                updateUIState(false);
            }
        };

        /**
         * New function to search for movies based on user's mood/interest.
         */
        window.searchByMood = async function() {
            const moodInput = document.getElementById('moodInput').value.trim();

            if (!moodInput) {
                updateUIState(false, true, "Please describe your mood or interest before searching.");
                return;
            }

            updateUIState(true); // Start loading

            const apiUrl = getApiUrl();

            // Define the JSON schema (same as before)
            const responseSchema = {
                type: "ARRAY",
                items: {
                    type: "OBJECT",
                    properties: {
                        "title": { "type": "STRING", "description": "Movie or TV Show Title" },
                        "year": { "type": "NUMBER", "description": "Release year" },
                        "genre": { "type": "STRING", "description": "Primary genre(s)" },
                        "origin": { "type": "STRING", "enum": ["Hollywood", "Bollywood"], "description": "Origin of the production" },
                        "rating": { "type": "NUMBER", "description": "Aggregate rating on a 1-10 scale (e.g., 8.5)" }, 
                        "summary": { "type": "STRING", "description": "A brief, one-sentence plot summary" }
                    },
                    "required": ["title", "year", "genre", "origin", "rating", "summary"]
                },
                "description": "A list of 5 to 10 recommended movies based on the user's mood/interest."
            };


            const systemPrompt = "You are a personalized film recommendation expert. Your sole task is to generate a JSON array of 5 to 10 highly relevant Bollywood and Hollywood movies or TV shows based on the user's specific mood, interest, or request. Use your internal knowledge. Ensure each entry adheres exactly to the provided JSON schema. Do not include any text outside of the JSON block.";
            const userQuery = `Find 5 to 10 movies (Bollywood or Hollywood) that perfectly match the user's request/mood: "${moodInput}". Provide detailed information for each as structured JSON.`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                // FIX: Removed "tools" key, as it's incompatible with "responseSchema".
                // tools: [{ "google_search": {} }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: responseSchema
                }
            };

            let movies = [];
            let sources = []; // Will remain empty, which is fine.
            
            try {
                const result = await window.fetchWithBackoff(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const candidate = result.candidates?.[0];

                if (candidate && candidate.content?.parts?.[0]?.text) {
                    const jsonText = candidate.content.parts[0].text;
                    try {
                        movies = JSON.parse(jsonText);
                    } catch (e) { // <-- SYNTAX FIX: Added curly braces
                        console.error("Failed to parse JSON response:", e);
                        throw new Error("The API returned data in an unexpected format. Please try again.");
                    } // <-- SYNTAX FIX: Added curly braces

                    // Extract grounding sources (no longer applicable, but code handles it)
                    const groundingMetadata = candidate.groundingMetadata;
                    if (groundingMetadata && groundingMetadata.groundingAttributions) {
                        sources = groundingMetadata.groundingAttributions
                            .map(attribution => ({
                                uri: attribution.web?.uri,
                                title: attribution.web?.title,
                            }))
                            .filter(source => source.uri && source.title);
                    }
                }
                
                renderResults(movies, sources, `Top ${movies.length} Recommendations for Your Mood`);

            } catch (error) {
                console.error("Movie Picker API Error:", error);
                updateUIState(false, true, `Failed to get personalized recommendations: ${error.message}`);
            } finally {
                updateUIState(false);
            }
        };
        
        /**
         * Generates a Hollywood-style elevator pitch and tagline for a specific movie.
         * (This function was likely correct, as it doesn't use 'tools')
         */
        window.generateMoviePitch = async function(button, title, summary, genre, origin) {
            // Revert escaped characters for API call
            const unescapedTitle = unescapeHtml(title);
            const unescapedSummary = unescapeHtml(summary);
            const unescapedGenre = unescapeHtml(genre);
            const unescapedOrigin = unescapeHtml(origin);

            const pitchDisplay = button.closest('.p-4').querySelector('.pitch-display');
            const songDisplay = button.closest('.p-4').querySelector('.song-display');

            // UI state management
            button.disabled = true;
            button.textContent = 'Generating...';
            // Hide both displays to avoid confusion
            pitchDisplay.classList.add('hidden');
            songDisplay.classList.add('hidden');
            pitchDisplay.innerHTML = '';


            const apiUrl = getApiUrl();

            // Structured output schema for the pitch
            const responseSchema = {
                type: "OBJECT",
                properties: {
                    "elevatorPitch": { "type": "STRING", "description": "A 1-2 sentence, exciting elevator pitch for the movie." },
                    "marketingTagline": { "type": "STRING", "description": "A powerful, catchy marketing tagline (maximum 5 words)." }
                },
                "required": ["elevatorPitch", "marketingTagline"]
            };

            const systemPrompt = "You are a top-tier Hollywood marketing executive. Your task is to generate a compelling 1-2 sentence elevator pitch and a powerful, short marketing tagline for the film described by the user. The output must be a valid JSON object matching the schema. Do not include any text outside of the JSON block.";
            const userQuery = `Movie Details: Title: "${unescapedTitle}", Genre: "${unescapedGenre}", Origin: "${unescapedOrigin}". Summary: "${unescapedSummary}". Create an original, exciting elevator pitch and a catchy tagline for this film.`;

            try {
                const payload = {
                    contents: [{ parts: [{ text: userQuery }] }],
                    systemInstruction: { parts: [{ text: systemPrompt }] },
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: responseSchema
                    }
                };

                const result = await window.fetchWithBackoff(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const candidate = result.candidates?.[0];
                if (candidate && candidate.content?.parts?.[0]?.text) {
                    const jsonText = candidate.content.parts[0].text;
                    const pitchData = JSON.parse(jsonText);
                    
                    pitchDisplay.innerHTML = `
                        <p class="font-bold text-purple-800 mb-1">Marketing Tagline:</p>
                        <p class="text-xl font-extrabold text-purple-900 mb-3">"${pitchData.marketingTagline}"</p>
                        <p class="font-bold text-purple-800 mb-1">Elevator Pitch:</p> <!-- TYPO FIX: was classF -->
                        <p class="text-purple-700">${pitchData.elevatorPitch}</p>
                    `;
                    pitchDisplay.classList.remove('hidden');
                } else {
                     pitchDisplay.innerHTML = `<p class="text-red-600">Could not generate pitch. Try again.</p>`;
                     pitchDisplay.classList.remove('hidden');
                }

            } catch (error) {
                console.error("Pitch Generation Error:", error);
                pitchDisplay.innerHTML = `<p class="text-red-600">Error generating pitch: ${error.message}</p>`;
                pitchDisplay.classList.remove('hidden');
            } finally {
                button.disabled = false;
                button.textContent = 'Generate Pitch âœ¨';
            }
        };

        /**
         * NEW FEATURE: Generates a theme song idea for a specific movie.
         * (This function was also likely correct, as it doesn't use 'tools')
         */
        window.generateThemeSongIdea = async function(button, title, summary, genre, origin) {
            // Revert escaped characters for API call
            const unescapedTitle = unescapeHtml(title);
            const unescapedSummary = unescapeHtml(summary);
            const unescapedGenre = unescapeHtml(genre);
            const unescapedOrigin = unescapeHtml(origin);
            
            const pitchDisplay = button.closest('.p-4').querySelector('.pitch-display');
            const songDisplay = button.closest('.p-4').querySelector('.song-display');

            // UI state management
            button.disabled = true;
            button.textContent = 'Generating...';
            // Hide both displays
            pitchDisplay.classList.add('hidden');
            songDisplay.classList.add('hidden');
            songDisplay.innerHTML = '';

            const apiUrl = getApiUrl();

            // Structured output schema for the song idea
            const responseSchema = {
                type: "OBJECT",
                properties: {
                    "songTitle": { "type": "STRING", "description": "A creative, original title for a theme song." },
                    "vibe": { "type": "STRING", "description": "A 1-2 sentence description of the song's vibe, instrumentation, and mood." }
                },
                "required": ["songTitle", "vibe"]
            };

            const systemPrompt = "You are a creative music supervisor for film. Your task is to invent an original theme song idea for the movie described. Generate a creative song title and a 1-2 sentence description of its vibe, mood, and instrumentation. The output must be a valid JSON object matching the schema. Do not include any text outside of the JSON block.";
            const userQuery = `Movie Details: Title: "${unescapedTitle}", Genre: "${unescapedGenre}", Origin: "${unescapedOrigin}". Summary: "${unescapedSummary}". Create an original theme song title and vibe description.`;

            try {
                const payload = {
                    contents: [{ parts: [{ text: userQuery }] }],
                    systemInstruction: { parts: [{ text: systemPrompt }] },
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: responseSchema
                    }
                };

                const result = await window.fetchWithBackoff(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const candidate = result.candidates?.[0];
                if (candidate && candidate.content?.parts?.[0]?.text) {
                    const jsonText = candidate.content.parts[0].text;
                    const songData = JSON.parse(jsonText);

                    songDisplay.innerHTML = `
                        <p class="font-bold text-green-800 mb-1">Theme Song Title:</p>
                        <p class="text-xl font-extrabold text-green-900 mb-3">"${songData.songTitle}"</p>
                        <p class="font-bold text-green-800 mb-1">Vibe & Style:</p>
                        <p class="text-green-700">${songData.vibe}</p>
                    `;
                    songDisplay.classList.remove('hidden');
                } else {
                     songDisplay.innerHTML = `<p class="text-red-600">Could not generate song idea. Try again.</p>`;
                     songDisplay.classList.remove('hidden');
                }

            } catch (error) {
                console.error("Song Generation Error:", error);
                songDisplay.innerHTML = `<p class="text-red-600">Error generating song idea: ${error.message}</p>`;
                songDisplay.classList.remove('hidden');
            } finally {
                button.disabled = false;
                button.textContent = 'Theme Song Idea âœ¨';
            }
        };


        // Initialize the application on load
        window.onload = initApp;

    </script>
</body>
</html>